% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dopri.R
\name{dopri}
\alias{dopri}
\alias{dopri5}
\alias{dopri853}
\title{Integrate ODE/DDE with dopri}
\usage{
dopri(y, times, func, parms, ..., n_out = 0L, output = NULL, rtol = 1e-06,
  atol = 1e-06, tcrit = NULL, method = "dopri5", n_history = 0,
  return_history = n_history > 0, dllname = "", parms_are_real = TRUE,
  ynames = TRUE, outnames = NULL, by_column = FALSE,
  return_initial = FALSE, return_statistics = FALSE, return_time = FALSE,
  deSolve_compatible = FALSE)

dopri5(y, times, func, parms, ...)

dopri853(y, times, func, parms, ...)
}
\arguments{
\item{y}{Initial conditions for the integration}

\item{times}{Times where output is needed.  Unlike \code{deSolve}
we won't actually stop at these times, but instead interpolate
back to get the result.}

\item{func}{Function to integrate.  Can be an R function of
arguments \code{t, y, parms}, returning a numeric vector, or it
can be the name or address of a C function with arguments
\code{size_t n, double t, double *y, double *dydt, void *data}.}

\item{parms}{Parameters to pass through to the derivatives.}

\item{...}{Dummy arguments - nothing is allowed here, but this
means that all further arguments \emph{must} be specified by
name (not order) so I can easily reorder them later on.}

\item{n_out}{Number of "output" variables (not differential
equation variables) to compute via the routine \code{output}.}

\item{output}{The output routine; either an R function taking
arguments \code{t, y, parms} or the name/address of a C function
taking arguments \code{size_t n, double t, const double *y,
size_t n_out, double *out, void *data}.}

\item{rtol}{The per-step relative tolerance.  The total accuracy
will be less than this.}

\item{atol}{The per-step absolute tolerance.}

\item{tcrit}{An optional vector of critical times that the solver
must stop at (rather than interpolating over).  This can include
an end time that we can't go past, or points within the
integration that must be stopped at exactly (for example cases
where the derivatives change abruptly).  Note that this differs
from the interpretation of this parameter in deSolve; there
\code{tcrit} is a single time that integration may not go past
-- with dde we never go past the final time, and this is just
for times that fall \emph{within} the range of times in
\code{times}.}

\item{method}{The integration method to use, as a string.  The
supported methods are \code{"dopri5"} (5th order method with 4th
order dense output) and \code{"dopri853"} (8th order method with
7th order output and embedded 5th and 3rd order schemes).
Alternatively, use the functions \code{dopri5} or
\code{dopri853} which simply sets this argument.}

\item{n_history}{Number of history points to retain.  This needs
to be greater than zero for delay differential equations to
work.  Alternatively, this may be greater than zero to return
model outputs that can be inspected later.}

\item{return_history}{Logical indicating if history should be
returned alongside the output or discarded.  By default, history
is retained if \code{n_history} is greater than 0, but that
might change (and may not be desirable unless you plan on
actually using it).}

\item{dllname}{Name of the shared library (without extension) to
find the function \code{func} (and \code{output} if given) in
the case where \code{func} refers to compiled function.}

\item{parms_are_real}{Logical, indicating if \code{parms} should
be treated as vector of doubles by \code{func} (when it is a
compiled function).  If \code{TRUE} (the default), then
\code{REAL(parms)}, which is \code{double*} is passed through.
If \code{FALSE} then if \code{params} is an externalptr type
(\code{EXTPTRSXP}) we pass through the result of
\code{R_ExternalPtrAddr}, otherwise we pass \code{params}
through unmodified as a \code{SEXP}.  In the last case, in your
target function you will need to include \code{<Rinternals.h>},
cast to \code{SEXP} and then pull it apart using the R API (or
Rcpp).}

\item{ynames}{Logical, indicating if the output should be named
following the names of the input vector \code{y}.
Alternatively, if \code{ynames} is a character vector of the
same length as \code{y}, these will be used as the output names.}

\item{outnames}{An optional character vector, used when
\code{n_out} is greater than 0, to name the model output matrix.}

\item{by_column}{Logical, indicating if the output should be
returned organised by column (rather than row).  This incurs a
slight cost for transposing the matrices.  If you can work with
matrices that are transposed relative to \code{deSolve}, then
set this to \code{FALSE}.}

\item{return_initial}{Logical, indicating if the output should
include the initial conditions (like deSolve).}

\item{return_statistics}{Logical, indicating if statistics about
the run should be included.  If \code{TRUE}, then an integer
vector containing the number of target evaluations, steps,
accepted steps and rejected steps is returned (the vector is
named).}

\item{return_time}{Logical, indicating if a row (or column if
\code{by_column} is \code{TRUE}) representing time is included
(this matches deSolve).}

\item{deSolve_compatible}{Logical, indicating if we should run in
"deSolve compatible" output mode.  This enables the options
\code{by_column}, \code{return_initial} and \code{return_time}.
This affects only some aspects of the output, and not the
calculations themselves.}
}
\value{
At present the return value is transposed relative to
  deSolve.  This might change in future.
}
\description{
Integrate an ODE or DDE with dopri.
}

